{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Introduction\r\n\r\nChefSpec makes it easy to write examples for Opscode Chef cookbooks. Get fast\r\nfeedback on cookbook changes before you spin up a node to do integration\r\nagainst.\r\n\r\nChefSpec runs your cookbook but without actually converging the node that your\r\nexamples are being executed on. This has two benefits:\r\n\r\n* It's really fast!\r\n* You can write examples that vary node attributes, operating system or search\r\n  results in order to test thoroughly that your cookbok works correctly.\r\n\r\nChefSpec aims to make Chef development more productive by giving you faster\r\nfeedback on cookbook changes.\r\n\r\nStart by watching Jim Hopp's excellent [Test Driven Development for Chef Practitioners](http://www.youtube.com/watch?v=o2e0aZUAVGw) talk from ChefConf which contains lots of great examples of using ChefSpec.\r\n\r\n# Writing a cookbook example\r\n\r\nThis is an extremely basic Chef recipe that just installs an operating system package.\r\n\r\n```ruby\r\n1  package \"foo\" do\r\n2    action :install\r\n3  end\r\n```\r\n\r\nThis is a matching spec file that defines an example that checks that the\r\npackage would be installed.\r\n\r\n```ruby\r\n1  require \"chefspec\"\r\n2\r\n3  describe \"example::default\" do\r\n4    let (:chef_run) { ChefSpec::ChefRunner.new.converge 'example::default' }\r\n5    it \"should install foo\" do\r\n6      chef_run.should install_package 'foo'\r\n7    end\r\n8  end\r\n```\r\n\r\nLet's step through this spec file to see what is happening:\r\n\r\n1. At the top of the spec file we require the chefspec gem.\r\n1. The `describe` keyword is part of RSpec and indicates that everything from\r\n   this line up until line 8 is describing the `example::default` recipe.\r\n   Normally the convention is that you would have a separate spec file per\r\n   recipe.\r\n1. The `let` block on line 4 creates the ChefSpec runner and then does a fake\r\n   Chef run with the run list of `example::default`. Any subsequent\r\n   examples can then refer to `chef_run` in order to make assertions about the\r\n   resources that were created during the mock converge.\r\n1. The `it` block on line 5 is an example that specifies that the `foo` package\r\n   should have been installed. Normally you will have multiple `it` blocks per\r\n   recipe, each making a single assertion.\r\n\r\n## Generating an example\r\n\r\nIdeally you should be writing your specs in tandem with your recipes and\r\npracticising TDD. However if you have an existing cookbook and you are using\r\nChef 0.10.0 or greater then ChefSpec can generate placeholder RSpec examples\r\nfor you. Knife will automagically detect the ChefSpec Knife Plugin and provide\r\nyou with the new `create_specs` subcommand.\r\n\r\nYou can choose to run this immediately after creating a new cookbook like so:\r\n\r\n    $ knife cookbook create -o . my_new_cookbook\r\n    $ knife cookbook create_specs -o . my_new_cookbook\r\n\r\nThe first command is a Knife built-in and will generate the standard Chef\r\ncookbook structure, including a default recipe. The second is provided by\r\nChefSpec and will add a `specs` directory and a `default_spec.rb` placeholder.\r\n\r\nYou'll see the following output:\r\n\r\n    ** Creating specs for cookbook: my_new_cookbook\r\n\r\nIf you look at the generated example you'll see that on line 6 there is a\r\n`pending` keyword indicating where you will later add your cookbook example:\r\n\r\n    $ cat -n my_new_cookbook/spec/default_spec.rb\r\n\r\n```ruby\r\n1  require 'chefspec'\r\n2\r\n3  describe 'my_new_cookbook::default' do\r\n4    let (:chef_run) { ChefSpec::ChefRunner.new.converge 'my_new_cookbook::default' }\r\n5    it 'should do something' do\r\n6      pending 'Your recipe examples go here.'\r\n7    end\r\n8  end\r\n```\r\n\r\nYou can run the example using rspec:\r\n\r\n    $ rspec my_new_cookbook\r\n\r\nAnd you'll see output similar to the following:\r\n\r\n    Pending:\r\n      my_new_cookbook::default should do something\r\n        # Your recipe examples go here.\r\n        # ./my_new_cookbook/spec/default_spec.rb:5\r\n\r\n    Finished in 0.00051 seconds\r\n    1 example, 0 failures, 1 pending\r\n\r\n# Examples should do more than restate static resources\r\n\r\nBeing able to write examples for simple cases like this is of some use, but\r\nbecause you declare resources in Chef declaratively it can feel like you are\r\nmerely repeating the same resources in example form.\r\n\r\nHowever the recipes that you write using Chef will often declare different\r\nresources based on different inputs:\r\n\r\n1. The node attributes for the node converged.\r\n1. The automatically populated node attributes provided by Ohai (operating\r\n   system and version are examples of these).\r\n1. Search results from search queries performed within the recipe.\r\n1. Lookup of values from within databags.\r\n\r\nThis is where ChefSpec really starts to shine. ChefSpec makes it possible to\r\nwrite examples for all of the variations of the different inputs above and\r\nmake assertions about the created resources. Verifying correct behaviour\r\nfor all of the variations with real converges can be incredibly time consuming.\r\nDoing this with real converges is prohibitively slow, but with ChefSpec you can\r\nidentify regressions very quickly while developing your cookbook.\r\n\r\n## Setting node attributes\r\n\r\nYou can set node attributes within an individual example. In this example\r\nthe value of the `foo` attribute will be set to `bar` on line 3. The example\r\nthen asserts that a resource is created based on the attribute name.\r\nIn this example the affected resource is a log resource, but it could just as\r\neasily be a template or package name derived from an attribute value.\r\n\r\n```ruby\r\n1  it \"should log the foo attribute\" do\r\n2    chef_run = ChefSpec::ChefRunner.new\r\n3    chef_run.node.foo = 'bar'\r\n4    chef_run.converge 'example::default'\r\n5    chef_run.should log 'The value of node.foo is: bar'\r\n6  end\r\n```\r\n\r\nA common mistake is to call `#converge` on the runner before setting the node\r\nattributes. If you do this then the attributes will not be set correctly.\r\n\r\n```ruby\r\n1  # Don't do this\r\n2  it \"should log the foo attribute\" do\r\n3    chef_run = ChefSpec::ChefRunner.new.converge 'example::default'\r\n4    chef_run.node.foo = 'bar'\r\n5    chef_run.should log 'The value of node.foo is: bar'\r\n6  end\r\n```\r\n\r\nTo avoid this, you can make use of the alternative syntax for specifying node\r\nattributes. Using this approach you pass a block when creating the runner.\r\n\r\n```ruby\r\n1  chef_run = ChefSpec::ChefRunner.new do |node|\r\n2    node['my_attribute'] = 'bar'\r\n3    node['my_other_attribute'] = 'bar2'\r\n4  end\r\n5  chef_run.converge 'example::default'\r\n```\r\n\r\n## Ohai Attributes\r\n\r\nWhen you converge a node using Chef a large number of attributes are\r\npre-populated by Chef which runs\r\n[Ohai](http://wiki.opscode.com/display/chef/Ohai) to discover information about\r\nthe node it is running on.\r\n\r\nYou can use these attributes within your cookbooks - the most common usage is\r\nto declare different resources based on the node platform (operating system)\r\nbut Ohai ships with a large number of plugins that discover everything from\r\nhardware to installed language interpreters.\r\n\r\nIt's useful to be able to override these values from within your cookbook\r\nexamples in order to assert the resources created on different platforms. In\r\nthis way you can explore all of the code paths within your cookbook despite\r\nrunning the examples on a different platform altogether. Note that line 2\r\ndeclares the platform underneath `automatic_attrs`.\r\n\r\n```ruby\r\n1  chef_run = ChefSpec::ChefRunner.new\r\n2  chef_run.node.automatic_attrs[:platform] = 'Commodore 64'\r\n3  chef_run.converge('example::default').should log\r\n4    'I am running on a Commodore 64.'\r\n```\r\n\r\n### Missing attributes\r\n\r\nBecause Ohai runs a large number of plugins by default, many community cookbooks\r\nwill assume that a node attribute will be present, and will fail unless a value\r\nis provided. Providing values for each of these attributes can detract from the\r\nreadability of your examples.\r\n\r\n[Fauxhai](https://github.com/customink/fauxhai) from Seth Vargo is a promising\r\nsolution to this problem because it enables you to re-use sanitized Ohai\r\nattribute profiles by name, rather than being required to provide each attribute\r\nindividually. For more on Fauxhai\r\n[check out this blog post](http://technology.customink.com/blog/2012/08/03/testing-chef-cookbooks/)\r\nfrom CustomInk.\r\n\r\n## Search Results\r\n\r\nChef cookbooks will often make use of search in order to locate other services\r\nwithin your infrastructure. An example would be a load balancer that searches\r\nfor the webservers to add to its pool.\r\n\r\nYou can use the built-in features within RSpec to stub out responses to search\r\nqueries. Given a recipe that searches for webservers:\r\n\r\n```ruby\r\n1  search(:node, 'role:web') do |web_node|\r\n2    log \"Adding webserver to the pool: #{web_node['hostname']}\"\r\n3  end\r\n```\r\n\r\nA example that returned a pre-canned search result to the recipe and then\r\nasserted that it then logged each node added to the pool might look like this:\r\n\r\n```ruby\r\n1  it \"should log each node added to the load balancer pool\" do\r\n2    Chef::Recipe.any_instance.stub(:search).with(:node, 'role:web').and_yield(\r\n3      {'hostname' => 'web1.example.com'})\r\n4    chef_run = ChefSpec::ChefRunner.new\r\n5    chef_run.converge 'my_new_cookbook::default'\r\n6    chef_run.should log 'Adding webserver to the pool: web1.example.com'\r\n7  end\r\n```\r\n\r\nLine 2 defines the search response for a search for all nodes with the `web`\r\nrole. Line 6 then asserts that the hostname of the returned node is logged as\r\nexpected.\r\n\r\n# Making Assertions\r\n\r\nNow you have a clear understanding of how to modify the attributes available to\r\nyour cookbook it's time to explore the support available in ChefSpec for\r\nexpressing assertions.\r\n\r\nEach example (within the `it` block) has to specify an assertion to be useful.\r\nAn assertion is a statement about the resources created by your Chef run that\r\nthe node will be converged against.\r\n\r\n## Files\r\n\r\nA basic form of assertion is to check that a file is created by a cookbook\r\nrecipe. Note that this won't work for files or directories that are not\r\nexplicitly declared as resources in the recipe. For example directories created\r\nby the installation of a new package are not known to ChefSpec, it is only\r\naware of resources that are defined within your cookbooks.\r\n\r\nAssert that a directory would be created:\r\n\r\n```ruby\r\nchef_run.should create_directory '/var/lib/foo'\r\n```\r\n\r\nAssert that a directory would be deleted:\r\n\r\n```ruby\r\nchef_run.should delete_directory '/var/lib/foo'\r\n```\r\n\r\nAssert that a directory would have the correct ownership:\r\n\r\n```ruby\r\nchef_run.directory('/var/lib/foo').should be_owned_by('user', 'group')\r\n```\r\n\r\nAssert that a file would be created:\r\n\r\n```ruby\r\nchef_run.should create_file '/var/log/bar.log'\r\n```\r\n\r\nAssert that a file would be deleted:\r\n\r\n```ruby\r\nchef_run.should delete_file '/var/log/bar.log'\r\n```\r\n\r\nAssert that a file would have the correct ownership:\r\n\r\n```ruby\r\nchef_run.file('/var/log/bar.log').should be_owned_by('user', 'group')\r\n```\r\n\r\nAssert that a file would have the expected content:\r\n\r\n```ruby\r\nchef_run.should create_file_with_content 'hello-world.txt', 'hello world'\r\n```\r\n\r\n## Packages\r\n\r\nNote that only packages explicitly declared in the cookbook will be matched by\r\nthese assertions. For example, a package installed only as a dependency of\r\nanother package would not be matched.\r\n\r\nAssert that a package would be installed:\r\n\r\n```ruby\r\nchef_run.should install_package 'foo'\r\n```\r\n\r\nAssert that a package would be installed at a fixed version:\r\n\r\n```ruby\r\nchef_run.should install_package_at_version 'foo', '1.2.3'\r\n```\r\n\r\nAssert that a package would be removed:\r\n\r\n```ruby\r\nchef_run.should remove_package 'foo'\r\n```\r\n\r\nAssert that a package would be purged:\r\n\r\n```ruby\r\nchef_run.should purge_package 'foo'\r\n```\r\n\r\nAssert that a package would be upgraded:\r\n\r\n```ruby\r\nchef_run.should upgrade_package 'foo'\r\n```\r\n\r\nAll of the assertions above are also valid for use with RubyGems:\r\n\r\n```ruby\r\nchef_run.should install_gem_package 'foo'\r\n```\r\n\r\n## Execute\r\n\r\nIf you make use of the `execute` resource within your cookbook recipes it is\r\nimportant to guard for idempotent behaviour. ChefSpec is not smart enough\r\nat present to be used to verify that an `only_if` or `not_if` condition would\r\nbe met however.\r\n\r\nAssert that a command would be run:\r\n\r\n```ruby\r\nchef_run.should execute_command 'whoami'\r\n```\r\n\r\nAssert that a command would not be run:\r\n\r\n```ruby\r\nchef_run.should_not execute_command 'whoami'\r\n```\r\n\r\n## Logging\r\n\r\nYou can assert that a log resource will be created. Note that this assertion\r\nwill not match direct use of `Chef::Log`.\r\n\r\nAssert that a log statement would be logged:\r\n\r\n```ruby\r\nchef_run.should log 'A log message from my recipe'\r\n```\r\n\r\nIf you want to be able to view the log output at the console you can control\r\nthe logging level when creating an instance of `ChefRunner` as below:\r\n\r\n```ruby\r\nlet(:chef_run) { ChefSpec::ChefRunner.new(:log_level => :debug) }\r\n```\r\n\r\n## Services\r\n\r\nAssert that a daemon would be started:\r\n\r\n```ruby\r\nchef_run.should start_service 'food'\r\n```\r\n\r\nAssert that a daemon would be started when the node boots:\r\n\r\n```ruby\r\nchef_run.should set_service_to_start_on_boot 'food'\r\n```\r\n\r\nAssert that a daemon would be stopped:\r\n\r\n```ruby\r\nchef_run.should stop_service 'food'\r\n```\r\n\r\nAssert that a daemon would be restarted:\r\n\r\n```ruby\r\nchef_run.should restart_service 'food'\r\n```\r\n\r\nAssert that a daemon would be reloaded:\r\n\r\n```ruby\r\nchef_run.should reload_service 'food'\r\n```\r\n\r\n# Varying the cookbook path\r\n\r\nBy default chefspec will infer the `cookbook_path` from the location of the\r\nspec. However if you want to use a different path you can pass it in as an\r\nargument to the `ChefRunner` constructor like so:\r\n\r\n```ruby\r\n 1 require 'chefspec'\r\n 2\r\n 3 describe 'foo::default' do\r\n 4   let (:chef_run) {\r\n 5     runner = ChefSpec::ChefRunner.new({:cookbook_path => '/some/path'})\r\n 6     runner.converge 'foo::default'\r\n 7     runner\r\n 8   }\r\n 9   it 'installs the foo package' do\r\n10     chef_run.should install_package 'foo'\r\n11   end\r\n12 end\r\n```\r\n\r\n# Building\r\n\r\n    $ bundle install\r\n    $ bundle exec rake\r\n\r\n# Continuous Integration\r\n[Chefspec on Travis CI](http://travis-ci.org/acrmp/chefspec)\r\n\r\n# License\r\nMIT - see the accompanying [LICENSE](https://github.com/acrmp/chefspec/blob/master/LICENSE) file for details.\r\n\r\n# Changelog\r\nTo see what has changed in recent versions see the [CHANGELOG](https://github.com/acrmp/chefspec/blob/master/CHANGELOG.md). ChefSpec follows the [Rubygems RationalVersioningPolicy](http://docs.rubygems.org/read/chapter/7).\r\n\r\n# Contributing\r\nAdditional matchers and bugfixes are welcome! Please fork and submit a pull request on an individual branch per change.\r\n","name":"Chefspec","google":"","tagline":"Write RSpec examples for Opscode Chef cookbooks"}